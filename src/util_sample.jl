# Several Lines within Turing.@model are modified by the macro and missingn in codecov - ok

"""
    function gen_model_cross(;
            inv_case::AbstractCrossInversionCase, tools, priors_pop, sim_sols_probs,
            scenario, psets, solver)

Generate a Turing model using objects generated by `setup_inversion` 
components: `indiv_info.tools`, `pop_info.priors_pop`, and `pop_info.psets`)
and forward simulation function generated by `gen_sim_sols_probs`.
"""
function gen_model_cross(;
        inv_case::AbstractCrossInversionCase, tools, priors_pop, sim_sols_probs,
        scenario, psets, solver)
    # fLogger = EarlyFilteredLogger(current_logger()) do log
    #     #@show log
    #     !(log.level == Logging.Warn && log.group == :integrator_interface)
    # end
    n_indiv = length(tools)
    sys_num_dict = get_system_symbol_dict(get_system(first(tools).problem))
    #obs = extract_stream_obsmatrices(;tools)
    obs = map(t -> t.indivdata, tools)
    obs_target = map(obs) do obs_site
        map(obs_site_stream -> obs_site_stream.obs, obs_site)
    end
    #
    gen_tmodel_cross = let pdf_deficit = Exponential(0.001),
        #prior_dist = prior_dist, 
        scenario = scenario,
        n_indiv = n_indiv, tools = tools,
        psets = map(get_concrete, psets),
        solver = solver,
        priors_pop = priors_pop,
        priors_indiv = [t.priors_indiv for t in tools],
        sim_sols_probs = sim_sols_probs,
        obs = obs,
        # assume all sites/indiv have same streams
        streams = keys(first(obs)),
        dtypes = (;
            zip(streams,
                (get_case_obs_uncertainty_dist_type(inv_case, s; scenario)
                for s in streams))...)
        #saveat = union(map_keys(stream -> stream.t, obs)),
        stream_nums = (;
            zip(streams,
                Symbolics.scalarize.(getindex.(Ref(sys_num_dict), streams)))...)

        Turing.@model function tmodel_cross(obs_target, ::Type{T} = Float64) where {T}
            npfix = count_paropt(psets.fixed)
            npranmul = count_paropt(psets.ranmul)
            npranadd = count_paropt(psets.ranadd)
            npsite = count_paropt(psets.indiv)
            fixed_nl = StaticArrays.MVector{npfix, T}(undef)
            #fixed_nl = Vector{T}(undef, npfix)
            fixed = fixed1 = label_paropt_flat1(psets.fixed, fixed_nl; omitwarning=true)
            #k = first(keys(fixed))
            for k in keys(fixed)
                fixed[k] ~ priors_pop.fixed[k]
                #fixed[k] = rand(priors_pop.fixed[k])
            end
            ranadd_nl = StaticArrays.MVector{npranadd, T}(undef)
            ranadd = label_paropt_flat1(psets.ranadd, ranadd_nl; omitwarning=true)
            #k = first(keys(ranadd))
            for k in keys(ranadd)
                ranadd[k] ~ priors_pop.ranadd[k]
                #ranadd[k] = rand(priors_pop.ranadd[k])
            end
            #ranmul = Vector{T}(undef, npranmul)
            ranmul_nl = StaticArrays.MVector{npranmul, T}(undef)
            ranmul = label_paropt_flat1(psets.ranmul, ranmul_nl; omitwarning=true)
            #k = first(keys(ranmul))
            for k in keys(ranmul)
                ranmul[k] ~ priors_pop.ranmul[k]
                #ranmul[k] = rand(priors_pop.ranmul[k])
            end
            #pranadd_σ = Vector{T}(undef, npranadd)
            pranadd_σ_nl = StaticArrays.MVector{npranadd, T}(undef)
            pranadd_σ = label_paropt_flat1(psets.ranadd, pranadd_σ_nl; omitwarning=true)
            #k = first(keys(pranadd_σ))
            for k in keys(pranadd_σ)
                pranadd_σ[k] ~ priors_pop.ranadd_σ[k]
                #pranadd_σ[k] = rand(priors_pop.ranadd_σ[k])
            end
            pranmul_σ_nl = StaticArrays.MVector{npranmul, T}(undef)
            pranmul_σ = label_paropt_flat1(psets.ranmul, pranmul_σ_nl; omitwarning=true)
            #k = first(keys(pranmul_σ))
            for k in keys(pranmul_σ)
                pranmul_σ[k] ~ priors_pop.ranmul_σ[k]
                #pranmul_σ[k] = rand(priors_pop.ranmul_σ[k])
            end
            # indiv = Matrix{T}(undef, npsite, n_indiv)
            # indiv_ranmul = Matrix{T}(undef, npranmul, n_indiv)
            #indiv1_l = label_paropt_flat1(psets.indiv, 1:count_par(psets.indiv); omitwarning=true)
            #template = label_paropt_flat1(psets.indiv, 1:count_paropt(psets.indiv); omitwarning=true)
            ax_indiv = axis_paropt_flat1(psets.indiv)
            indiv_nl = StaticArrays.MMatrix{npsite, n_indiv, T}(undef)
            indiv = ComponentArray(getdata(indiv_nl), ax_indiv, FlatAxis())
            indiv_ranadd_nl = StaticArrays.MMatrix{npranadd, n_indiv, T}(undef)
            indiv_ranadd = ComponentArray(getdata(indiv_ranadd_nl),
                first(getaxes(ranadd)), FlatAxis())
            indiv_ranmul_nl = StaticArrays.MMatrix{npranmul, n_indiv, T}(undef)
            indiv_ranmul = ComponentArray(getdata(indiv_ranmul_nl),
                first(getaxes(ranmul)), FlatAxis())
            #i_indiv = 1
            # compute all indiv effects first because of order of variables in sample
            # requires to split the loop
            for i_indiv in 1:n_indiv
                prior_indiv = priors_indiv[i_indiv]
                #k = first(keys(prior_indiv))
                for k in keys(prior_indiv)
                    indiv[k, i_indiv] ~ prior_indiv[k]
                    #indiv[k,i_indiv] = rand(prior_indiv[k])
                end
            end
            for i_indiv in 1:n_indiv
                #k = first(keys(pranadd_σ))
                for k in keys(pranadd_σ)
                    ne = length(pranadd_σ[k])
                    d = ne == 1 ?
                        fit_mean_Σ(Normal, 0.0, pranadd_σ[k]) :
                        fit_mean_Σ(Normal, fill(0.0, ne), PDiagMat(pranadd_σ[k] .^ 2))
                    indiv_ranadd[k, i_indiv] ~ d
                    #indiv_ranadd[k,i_indiv] = rand(d)
                end
            end
            for i_indiv in 1:n_indiv
                #k = first(keys(pranmul_σ))
                for k in keys(pranmul_σ)
                    ne = length(pranmul_σ[k])
                    d = ne == 1 ?
                        fit_mean_Σ(LogNormal, 1.0, pranmul_σ[k]) :
                        fit_mean_Σ(MvLogNormal, fill(1.0, ne), PDiagMat(pranmul_σ[k] .^ 2))
                    indiv_ranmul[k, i_indiv] ~ d
                    #indiv_ranmul[k,i_indiv] = rand(d)
                end
            end
            #poptl = CA.ComponentVector(popt, first(getaxes(popt0)))
            #poptl = CA.ComponentVector(
            #   vcat(fixed, ranadd, ranmul, pranadd_σ, pranmul_σ, vec(indiv), vec(indiv_ranadd), vec(indiv_ranmul)), first(getaxes(popt0)))
            #@show poptl
            # sampling changes eltype of Any, need to convert back
            res_sim = sim_sols_probs(
                convert(typeof(fixed_nl),
                    getdata(fixed))::typeof(fixed_nl),
                convert(typeof(ranadd_nl), getdata(ranadd))::typeof(ranadd_nl),
                convert(typeof(ranmul_nl), getdata(ranmul))::typeof(ranmul_nl),
                convert(typeof(indiv_nl), getdata(indiv))::typeof(indiv_nl),
                convert(typeof(indiv_ranadd_nl),
                    getdata(indiv_ranadd))::typeof(indiv_ranadd_nl),                #saveat = saveat)
                convert(typeof(indiv_ranmul_nl),
                    getdata(indiv_ranmul))::typeof(indiv_ranmul_nl);                #saveat = saveat)
            )
            #i_indiv = 1
            for i_indiv in 1:n_indiv
                # not in 1.6 (; sol, problem_opt) = res_sim[i_indiv]
                (sol, problem_opt) = res_sim[i_indiv]
                #!is_dual && @show popt, sol.retcode
                if !SciMLBase.successful_retcode(sol.retcode)
                    Turing.@addlogprob! -Inf
                    return
                end
                local parl = get_par_labeled(psets.fixed, problem_opt) #@inferred label_par(psetci, problem_opt.p)
                # for accessing solution at 100 time points need to store full solution
                for stream in streams
                    obss = obs[i_indiv][stream]
                    pred = sol(obss.t; idxs = stream_nums[stream]).u
                    #(i,t) = first(enumerate(obss.t))
                    for (i, t) in enumerate(obss.t)
                        pred_t = pred[i]
                        unc = obss.obs_unc[i]
                        dist_pred = fit_mean_Σ(dtypes[stream], pred_t, unc)
                        #tmp = rand(dist_pred)
                        obs_target[i_indiv][stream][i] ~ dist_pred
                        #obss.obs[i] = rand(dist_pred)
                    end
                end
                # TODO allow for specialized adjustment of logprob
            end # for i_indiv
            :return_from_tmodel_cross
        end # function      
    end # let
    #
    # target observations need to be subsequent values -> extract from general obs
    # that holds also the uncertainties and more
    gen_tmodel_cross(obs_target)
end

"""
    get_init_mixedmodel(fixed::ComponentVector, ranadd::ComponentVector, ranmul::ComponentVector, indiv::ComponentMatrix,
        priors_σ, indiv_ranadd, indiv_ranmul)

Construct a ComponentVector corresponding to the parameters sampled by the mixed model.
Argument `indiv` should hold individual identifiers as column axis.

The return has components
`fixed`, `ranmul`, `ranmul_σ`, `indiv`, `indiv_ranmul`
where `indiv` is a flat version with column names as entries of vectors.
"""
function get_init_mixedmodel(
        psets, popt_indiv::AbstractVector{<:ComponentVector}, priors_σ;
        kwargs...)
    (; fixed, ranadd, ranmul, indiv, indiv_ranadd, indiv_ranmul) = extract_mixed_effects(
        psets, popt_indiv; kwargs...)
    get_init_mixedmodel(;
        fixed, ranadd, ranmul, indiv, priors_σ, indiv_ranadd, indiv_ranmul)
end

"""
    extract_mixed_effects(psets, popt_indiv::AbstractVector{<:ComponentVector};
    
Extract mixed effects in the format supplied to sim_obs from parameters
of individuals.
"""
function extract_mixed_effects(psets, popt_indiv::AbstractVector{<:ComponentVector};
        indiv_ids = ((Symbol("i$i") for i in 1:length(popt_indiv))...,))
    popt_indiv_flat1 = flatten1.(popt_indiv)
    keys_p = map(pset -> keys(axis_paropt_flat1(pset)), psets)
    keys_opt = MTKHelpers.tuplejoin(keys_p...)
    #k = first(keys_opt) # k = keys_opt[2]
    popt_mean = ComponentVector(;
        ((k, mean(getproperty.(popt_indiv_flat1, k))) for k in keys_opt)...)
    fixed = subvector(popt_mean, keys_p.fixed)
    ranadd = subvector(popt_mean, keys_p.ranadd)
    ranmul = subvector(popt_mean, keys_p.ranmul)
    ax_site = Axis(indiv_ids)
    #@show indiv_ids, ax_site
    indiv = ComponentMatrix(hcat((popt[keys_p.indiv] for popt in popt_indiv_flat1)...),
        axis_paropt_flat1(psets.indiv), ax_site)
    #popt = first(popt_indiv_flat1)
    indiv_ranadd = ComponentMatrix(
        hcat((popt[keys_p.ranadd] .- popt_mean[keys_p.ranadd] for popt in popt_indiv_flat1)...),
        axis_paropt_flat1(psets.ranadd), ax_site)
    indiv_ranmul = ComponentMatrix(
        hcat((popt[keys_p.ranmul] ./ popt_mean[keys_p.ranmul] for popt in popt_indiv_flat1)...),
        axis_paropt_flat1(psets.ranmul), ax_site)
    (; fixed, ranadd, ranmul, indiv, indiv_ranadd, indiv_ranmul)
end

"""
Get a ComponentVector of only keys in cv. Takes care of special case of empty
keys, where it returns a ComponentVector rather than a plain Vector.
"""
function subvector(cv::ComponentVector, keys)
    isempty(keys) ? ComponentVector{eltype(cv)}() : cv[keys]
end

"""
    extract_mixed_effects(sample_i::AbstractVector{<:Number}; sample0=nothing
    
Extract mixed effects in the format supplied to sim_obs from linear sample.
May provide the axis with template ComponentVector `sample_0`.
"""
function extract_mixed_effects(sample_i::AbstractVector{<:Number}; sample0=nothing)
    sl = sample_i isa ComponentVector ? sample_i :
         MTKHelpers.attach_axis(sample_i, CA.getaxes(sample0)[1])
    indiv1 = sl.indiv[first(keys(sl.indiv))]
    ax_indiv = isempty(indiv1) ? CA.FlatAxis() : first(CA.getaxes(indiv1))
    ax_ranadd = isempty(sl.ranadd) ? CA.FlatAxis() : first(CA.getaxes(sl.ranadd))
    ax_ranmul = isempty(sl.ranmul) ? CA.FlatAxis() : first(CA.getaxes(sl.ranmul))
    ax_site = CA.Axis(keys(sl.indiv))
    n_site = length(keys(sl.indiv))
    mixed_i = (; sl.fixed, sl.ranadd, sl.ranmul, #sl.ranadd_σ, sl.ranmul_σ,
        indiv = CA.ComponentMatrix(
            reshape(sl.indiv, trunc(Int, length(sl.indiv) / n_site), n_site),
            ax_indiv, ax_site),
        indiv_ranadd = CA.ComponentMatrix(
            reshape(sl.indiv_ranadd, trunc(Int, length(sl.indiv_ranadd) / n_site), n_site), ax_ranadd, ax_site),
        indiv_ranmul = CA.ComponentMatrix(
            reshape(sl.indiv_ranmul, trunc(Int, length(sl.indiv_ranmul) / n_site), n_site), ax_ranmul, ax_site))
end


"""
inverse of extract_mixed_effects(samplei)
"""
function get_init_mixedmodel(;
        fixed::ComponentVector, ranadd::ComponentVector, ranmul::ComponentVector,
        indiv::ComponentMatrix, priors_σ,
        indiv_ranadd = missing, indiv_ranmul = missing
)
    ranadd_σ = ComponentVector(;
        ((k, mean(priors_σ[k])) for k in keys(ranadd))...)
    if ismissing(indiv_ranadd)
        n_indiv = size(indiv, 2)
        ax_ranadd = first(getaxes(ranadd))
        ax_site = getaxes(indiv)[2]
        indiv_ranadd = ComponentMatrix(fill(0.0, length(ranadd), n_indiv),
            ax_ranadd, ax_site)
    end
    ranmul_σ = ComponentVector(;
        ((k, mean(priors_σ[k])) for k in keys(ranmul))...)
    if ismissing(indiv_ranmul)
        n_indiv = size(indiv, 2)
        ax_ranmul = first(getaxes(ranmul))
        ax_site = getaxes(indiv)[2]
        indiv_ranmul = ComponentMatrix(fill(1.0, length(ranmul), n_indiv),
            ax_ranmul, ax_site)
    end
    ComponentVector(; fixed, ranadd, ranmul,
        ranadd_σ, ranmul_σ,
        indiv = flatten_cm(indiv),
        indiv_ranadd = flatten_cm(indiv_ranadd),
        indiv_ranmul = flatten_cm(indiv_ranmul)
    )
end

"""
    flatten_cm(cm::ComponentMatrix)

Return a flat version of ComponentMatrix cm.
"""
function flatten_cm(cm::ComponentMatrix)
    template = ComponentVector(; ((k, cm[:, k]) for k in keys(getaxes(cm)[2]))...)
    ComponentArray(vec(cm), getaxes(template))
end

# MAYBE - move to proper place
# function map_keys2(FUN, cv::ComponentVector; rewrap::Val{is_rewrap}=Val(true)) where {is_rewrap}
#     f1 = (k) -> begin
#         ret = FUN(k, cv[k])
#         eltype(ret) != Union{} ||
#             error("For mapping empty keys, provide a proper eltype." *
#                   "Did you accidentally write key=[] instead of e.g. Float64[] ?")
#         (k, ret)
#     end
#     if is_rewrap
#         gen = (f1(k) for k in keys(cv))
#         ComponentVector(;gen...)
#     else
#         map(k -> FUN(k, cv[k]), keys(cv))
#     end
# end
