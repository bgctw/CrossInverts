var documenterSearchIndex = {"docs":
[{"location":"example_vec/","page":"Walkthrough","title":"Walkthrough","text":"CurrentModule = CrossInverts","category":"page"},{"location":"example_vec/#Walkthrough","page":"Walkthrough","title":"Walkthrough","text":"","category":"section"},{"location":"example_vec/","page":"Walkthrough","title":"Walkthrough","text":"This example demonstrates how  using an example system with symbolic array state and symbolic array parameters.","category":"page"},{"location":"example_vec/#Example-system","page":"Walkthrough","title":"Example system","text":"","category":"section"},{"location":"example_vec/","page":"Walkthrough","title":"Walkthrough","text":"using ModelingToolkit, OrdinaryDiffEq \nusing ModelingToolkit: t_nounits as t, D_nounits as D\nusing ComponentArrays: ComponentArrays as CA\nusing MTKHelpers\nusing CrossInverts\nusing DistributionFits\nusing PDMats: PDiagMat\nusing Turing\n\nfunction samplesystem_vec(; name, τ = 3.0, i = 0.1, p = [1.1, 1.2, 1.3])\n    n_comp = 2\n    @parameters t\n    D = Differential(t)\n    @variables x(..)[1:n_comp] dec2(..) \n    ps = @parameters τ=τ i=i i2 p[1:3]=p\n    sts = vcat([x(t)[i] for i in 1:n_comp], dec2(t))\n    eq = [\n        D(x(t)[1]) ~ i - p[1] * x(t)[1] + (p[2] - x(t)[1]^2) / τ,\n        D(x(t)[2]) ~ i - dec2(t) + i2,\n        dec2(t) ~ p[3] * x(t)[2], # observable\n    ]\n    sys = ODESystem(eq, t, sts, vcat(ps...); name)\nend\n\n@named sv = samplesystem_vec()\n@named system = embed_system(sv)","category":"page"},{"location":"example_vec/","page":"Walkthrough","title":"Walkthrough","text":"First, we define which parameters should be calibrated as fixed, random, or individual parameters. Note, that we can use symbols rather than Symbolics, and can use symbolic arrays rather than requiring the scalarized version.","category":"page"},{"location":"example_vec/","page":"Walkthrough","title":"Walkthrough","text":"mixed_keys = (;\n    fixed = (:sv₊p,),\n    random = (:sv₊x, :sv₊τ),\n    indiv = (:sv₊i,),)\n\nindiv_ids = (:A, :B, :C)\nnothing # hide","category":"page"},{"location":"example_vec/#Priors,-Observations,-and-Observation-uncertainty","page":"Walkthrough","title":"Priors, Observations, and Observation uncertainty","text":"","category":"section"},{"location":"example_vec/","page":"Walkthrough","title":"Walkthrough","text":"We need to provide additional information to the inversion, such as observations, observation uncertainties, and prior distribution. This is achieved by overriding specific functions with the first argument being a specific subtype of AbstractCrossInversionCase corresponding to the inversion problem.","category":"page"},{"location":"example_vec/","page":"Walkthrough","title":"Walkthrough","text":"Here, we define singleton type DocuVecCase and provide priors with function  get_priors_dict. For simplicity we return the same priors independent  of the individual or the scenario. Take care to add methods to the function in module CrossInverts rather define the function in module Main. For the SymbolicArray parameters, we need to provide a Multivariate distribution. Here, we provide a product distribution of uncorrelated LogNormal distributions, which are specified by its mode and upper quantile using df_from_paramsModeUpperRows.","category":"page"},{"location":"example_vec/","page":"Walkthrough","title":"Walkthrough","text":"struct DocuVecCase <: AbstractCrossInversionCase end\n\nfunction CrossInverts.get_priors_dict(::DocuVecCase, indiv_id; scenario = NTuple{0, Symbol}())\n    #using DataFrames, Tables, DistributionFits, Chain\n    paramsModeUpperRows = [\n        # τ = 3.0, i = 0.1, p = [1.1, 1.2, 1.3])\n        (:sv₊i, LogNormal, 1.0, 6.0),\n        (:sv₊τ, LogNormal, 1.0, 5.0),\n        (:sv₊x_1, LogNormal, 1.0, 2.0),\n        (:sv₊x_2, LogNormal, 1.0, 2.0),\n    ]\n    df_scalars = df_from_paramsModeUpperRows(paramsModeUpperRows)\n    dd = Dict{Symbol, Distribution}(df_scalars.par .=> df_scalars.dist)\n    dist_p0 = fit(LogNormal, @qp_m(1.0), @qp_uu(3.0))\n    # dd[:sv₊p] = product_distribution(fill(dist_p0, 3))\n    # dd[:sv₊x] = product_distribution(dd[:sv₊x_1], dd[:sv₊x_2])\n    dd[:sv₊p] = product_MvLogNormal(fill(dist_p0, 3)...)\n    dd[:sv₊x] = product_MvLogNormal(dd[:sv₊x_1], dd[:sv₊x_2])\n    dd\nend\nfunction product_MvLogNormal(comp...)\n    μ = collect(getproperty.(comp, :μ))\n    σ = collect(getproperty.(comp, :σ))\n    Σ = PDiagMat(exp.(σ))\n    MvLogNormal(μ, Σ)\nend\n\ninv_case = DocuVecCase()\nscenario = NTuple{0, Symbol}()\n\nget_priors_dict(inv_case, :A; scenario)","category":"page"},{"location":"example_vec/","page":"Walkthrough","title":"Walkthrough","text":"Similarly, we provide prior distributions for uncertainty of the random effects by function get_priors_random_dict.","category":"page"},{"location":"example_vec/","page":"Walkthrough","title":"Walkthrough","text":"function CrossInverts.get_priors_random_dict(::DocuVecCase; scenario = NTuple{0, Symbol}())\n    # prior in σ rather than σstar\n    d_exp = Exponential(log(1.05))\n    dd = Dict{Symbol, Distribution}([:sv₊τ, :sv₊i] .=> d_exp)\n    dd[:sv₊x] = Distributions.Product(fill(d_exp, 2))\n    dd\nend\n\nget_priors_random_dict(inv_case; scenario)","category":"page"},{"location":"example_vec/","page":"Walkthrough","title":"Walkthrough","text":"Further, the type of distribution of observation uncertainties of  the observations of different data streams by function  get_obs_uncertainty_dist_type.","category":"page"},{"location":"example_vec/","page":"Walkthrough","title":"Walkthrough","text":"function CrossInverts.get_obs_uncertainty_dist_type(::DocuVecCase, stream;\n        scenario = NTuple{0, Symbol}())\n    dtypes = Dict{Symbol, Type}(:sv₊dec2 => LogNormal,\n        :sv₊x => MvLogNormal)\n    dtypes[stream]\nend\n\nget_obs_uncertainty_dist_type(inv_case, :sv₊dec2; scenario)","category":"page"},{"location":"example_vec/","page":"Walkthrough","title":"Walkthrough","text":"Finally, for each","category":"page"},{"location":"example_vec/","page":"Walkthrough","title":"Walkthrough","text":"each individual, \nfor each stream, ","category":"page"},{"location":"example_vec/","page":"Walkthrough","title":"Walkthrough","text":"we provide a vectors of","category":"page"},{"location":"example_vec/","page":"Walkthrough","title":"Walkthrough","text":"t: time\nobs: observations (vectors for multivariate variables)\nobs_unc: observation uncertainty parameters (can be matrices for multivariate variables)\nobs_true (optionally): values of the true model to be rediscovered in synthetic experiments","category":"page"},{"location":"example_vec/","page":"Walkthrough","title":"Walkthrough","text":"This is done by implementing function get_indivdata. Usually, this would be read information from a file or database. Here, we provide  the numbers as text.","category":"page"},{"location":"example_vec/","page":"Walkthrough","title":"Walkthrough","text":"function CrossInverts.get_indivdata(::DocuVecCase, indiv_id; scenario = NTuple{0, Symbol}())\n    data = (A = (sv₊x = (t = [0.2, 0.4, 1.0, 2.0],\n                obs = [\n                    [2.3696993004601956, 2.673733320916141],\n                    [1.8642844249865063, 2.0994355527637607],\n                    [1.9744553950945931, 2.049494086682751],\n                    [1.806115091024414, 1.4088107777562726],\n                ],\n                obs_unc = [\n                    [0.09531017980432493 0.0; 0.0 0.09531017980432493],\n                    [0.09531017980432493 0.0; 0.0 0.09531017980432493],\n                    [0.09531017980432493 0.0; 0.0 0.09531017980432493],\n                    [0.09531017980432493 0.0; 0.0 0.09531017980432493],\n                ],\n                obs_true = [\n                    [1.4528506430586314, 1.502300054146255],\n                    [1.2174085538439976, 1.1706665606844529],\n                    [1.0483430119731987, 0.7600115428483291],\n                    [1.0309694961068738, 0.6441417808271487],\n                ]),\n            sv₊dec2 = (t = [0.2, 0.4, 1.0, 2.0],\n                obs = [\n                    3.7951565919532038,\n                    2.932295276687423,\n                    2.0064853619502925,\n                    1.6522510350996853,\n                ],\n                obs_unc = [1.1, 1.1, 1.1, 1.1],\n                obs_true = [\n                    3.606705597390664,\n                    2.810523520548073,\n                    1.8246274291924653,\n                    1.546448567322152,\n                ])),\n        B = (sv₊x = (t = [0.2, 0.4, 1.0, 2.0],\n                obs = [\n                    [2.0681893973690264, 2.76555266499398],\n                    [3.002213659926257, 2.738988031384357],\n                    [2.2024778579768736, 1.8863521088263966],\n                    [1.8970493973645883, 1.4592874111525584],\n                ],\n                obs_unc = [\n                    [0.09531017980432493 0.0; 0.0 0.09531017980432493],\n                    [0.09531017980432493 0.0; 0.0 0.09531017980432493],\n                    [0.09531017980432493 0.0; 0.0 0.09531017980432493],\n                    [0.09531017980432493 0.0; 0.0 0.09531017980432493],\n                ],\n                obs_true = [\n                    [1.4319499386364825, 1.4846599446224278],\n                    [1.2097697867481565, 1.1597529395039063],\n                    [1.0512489486634184, 0.7574273823278419],\n                    [1.035264629162679, 0.6439076211840167],\n                ]),\n            sv₊dec2 = (t = [0.2, 0.4, 1.0, 2.0],\n                obs = [\n                    5.286801850397016,\n                    2.9649984441621826,\n                    2.1180756620394585,\n                    2.6749483017364,\n                ],\n                obs_unc = [1.1, 1.1, 1.1, 1.1],\n                obs_true = [\n                    3.5643554146940866,\n                    2.784322217758367,\n                    1.8184234047779861,\n                    1.5458863994028762,\n                ])),\n        C = (sv₊x = (t = [0.2, 0.4, 1.0, 2.0],\n                obs = [\n                    [2.2350643301157382, 2.3130035358019856],\n                    [2.0736166580761624, 1.9436035468232888],\n                    [2.0472448291872816, 1.529804596360485],\n                    [1.8267544248914431, 1.2760177129115113],\n                ],\n                obs_unc = [\n                    [0.09531017980432493 0.0; 0.0 0.09531017980432493],\n                    [0.09531017980432493 0.0; 0.0 0.09531017980432493],\n                    [0.09531017980432493 0.0; 0.0 0.09531017980432493],\n                    [0.09531017980432493 0.0; 0.0 0.09531017980432493],\n                ],\n                obs_true = [\n                    [1.4810168420659708, 1.502512426277095],\n                    [1.226148237932659, 1.1707979724544357],\n                    [1.0387515337959667, 0.7600427779041109],\n                    [1.0183823891718273, 0.6441445598911335],\n                ]),\n            sv₊dec2 = (t = [0.2, 0.4, 1.0, 2.0],\n                obs = [\n                    4.026668907719985,\n                    3.1937462073315097,\n                    6.2700505882164785,\n                    3.4322758342125548,\n                ],\n                obs_unc = [1.1, 1.1, 1.1, 1.1],\n                obs_true = [\n                    3.607215458087877,\n                    2.8108390124932754,\n                    1.8247024179739757,\n                    1.5464552392686794,\n                ])))\n    data[indiv_id]\nend\n\nget_indivdata(inv_case, :A; scenario)","category":"page"},{"location":"example_vec/","page":"Walkthrough","title":"Walkthrough","text":"Often, when one parameter is adjusted, this has consequences for other non-optimized parameters. Function get_problemupdater allows to provide a ParameterUpdater  to take care. In this example, when optimizing parameter i, then parameter i2 is set to the same value.","category":"page"},{"location":"example_vec/","page":"Walkthrough","title":"Walkthrough","text":"function CrossInverts.get_problemupdater(::DocuVecCase; system, scenario = NTuple{0, Symbol}())\n    mapping = (:sv₊i => :sv₊i2,)\n    pset = ODEProblemParSetter(system, Symbol[]) # parsetter to get state symbols\n    get_ode_problemupdater(KeysProblemParGetter(mapping, keys(axis_state(pset))), system)\nend\n\nget_problemupdater(inv_case; system, scenario)","category":"page"},{"location":"example_vec/#Extracting-initial-information-and-tools","page":"Walkthrough","title":"Extracting initial information and tools","text":"","category":"section"},{"location":"example_vec/","page":"Walkthrough","title":"Walkthrough","text":"A first estimate of the optimized initial state and parameters can then be obtained from priors using function get_indiv_parameters_from_priors. Because parameter i2 is not optimized, we specify a value rather than a prior. Next a set of tools is created using function setup_tools_mixed","category":"page"},{"location":"example_vec/","page":"Walkthrough","title":"Walkthrough","text":"p_indiv = get_indiv_parameters_from_priors(inv_case; \n    scenario, indiv_ids, mixed_keys, system,\n    p_default=CA.ComponentVector(sv₊i2 = 0.1))\n(;mixed, indiv_info, pop_info) = setup_tools_mixed(p_indiv;\n    inv_case, scenario, system, mixed_keys)\n#(psets, priors_pop, sample0, effect_pos) = pop_info\nkeys(pop_info.sample0)","category":"page"},{"location":"example_vec/","page":"Walkthrough","title":"Walkthrough","text":"A single sample is a ComponentVector with components","category":"page"},{"location":"example_vec/","page":"Walkthrough","title":"Walkthrough","text":"fixed: fixed effects\nrandom: mean random effects\nrandom_σ: uncertainty parameter of the random effects\nindiv: Component vector of each site with individual effects\nindiv_random: ","category":"page"},{"location":"example_vec/","page":"Walkthrough","title":"Walkthrough","text":"A reminder of the effects:","category":"page"},{"location":"example_vec/","page":"Walkthrough","title":"Walkthrough","text":"mixed_keys","category":"page"},{"location":"example_vec/","page":"Walkthrough","title":"Walkthrough","text":"Accessing single components.","category":"page"},{"location":"example_vec/","page":"Walkthrough","title":"Walkthrough","text":"pop_info.sample0[:random]","category":"page"},{"location":"example_vec/","page":"Walkthrough","title":"Walkthrough","text":"pop_info.sample0[:indiv][:A]","category":"page"},{"location":"example_vec/#Forward-simulation","page":"Walkthrough","title":"Forward simulation","text":"","category":"section"},{"location":"example_vec/","page":"Walkthrough","title":"Walkthrough","text":"Although not necessary for the inversion, it can be helpful for  analysing to do a single forward simulation for all individuals  for a given estimate of the effects.","category":"page"},{"location":"example_vec/","page":"Walkthrough","title":"Walkthrough","text":"First, a function is created using gen_sim_sols_probs  that requires an estimate of the effects, and returns the solution and the updated problem for each individual. Then this function is called with initial estimates.","category":"page"},{"location":"example_vec/","page":"Walkthrough","title":"Walkthrough","text":"solver = AutoTsit5(Rodas5P())\nsim_sols_probs = gen_sim_sols_probs(; \n    tools = indiv_info.tools, psets = pop_info.psets, \n    problemupdater = pop_info.problemupdater, solver)\n(fixed, random, indiv, indiv_random) = mixed\nsols_probs = sim_sols_probs(fixed, random, indiv, indiv_random)\n(sol, problem_opt) = sols_probs[1]\nsol[:sv₊x]\nnothing # hide","category":"page"},{"location":"example_vec/","page":"Walkthrough","title":"Walkthrough","text":"Below we just check that the ProblemUpdater really updated the non-optimized parameter i2 to the value of the optimized parameter i.","category":"page"},{"location":"example_vec/","page":"Walkthrough","title":"Walkthrough","text":"pset = pop_info.psets.fixed\nget_par_labeled(pset, problem_opt)[:sv₊i2] == get_par_labeled(pset, problem_opt)[:sv₊i]","category":"page"},{"location":"example_vec/#Model-Inversion","page":"Walkthrough","title":"Model Inversion","text":"","category":"section"},{"location":"example_vec/","page":"Walkthrough","title":"Walkthrough","text":"First, a Turing-model is created using gen_model_cross. Next, a few samples are drawn from this model using the NUTS sampler.","category":"page"},{"location":"example_vec/","page":"Walkthrough","title":"Walkthrough","text":"model_cross = gen_model_cross(;\n    inv_case, tools = indiv_info.tools, \n    priors_pop = pop_info.priors_pop, psets = pop_info.psets, \n    sim_sols_probs, scenario, solver);\n\nn_burnin = 0\nn_sample = 10\nchn = Turing.sample(model_cross, Turing.NUTS(n_burnin, 0.65, init_ϵ = 0.2), n_sample,\n    init_params = collect(pop_info.sample0))\n\nnames(chn, :parameters)","category":"page"},{"location":"example_vec/","page":"Walkthrough","title":"Walkthrough","text":"For each scalarized value of the effects there is a series of samples.","category":"page"},{"location":"example_vec/","page":"Walkthrough","title":"Walkthrough","text":"a single estimate for each fixed effect. For multivariate variables","category":"page"},{"location":"example_vec/","page":"Walkthrough","title":"Walkthrough","text":"the index is appended last, e.g. Symbol(\"fixed[:sv₊p][1]\").","category":"page"},{"location":"example_vec/","page":"Walkthrough","title":"Walkthrough","text":"a single mean random effect, e.g. Symbol(\"random[:sv₊τ]\").\nan uncertainty parameter of the random effect, e.g. Symbol(\"prand_σ[:sv₊τ]\").\na individual effect for each individual, e.g. Symbol(\"indiv[:sv₊i, 3]\")  for the third individual.\nthe individual multiplier for the random effect for each individual, e.g. Symbol(\"indiv_random[:sv₊τ, 3]\").","category":"page"},{"location":"example_vec/#Extracting-individual-effects","page":"Walkthrough","title":"Extracting individual effects","text":"","category":"section"},{"location":"example_vec/","page":"Walkthrough","title":"Walkthrough","text":"Each row of a multivariate chain can be extracted as a ComponentVector as described in [Extracting effects from sampled object].","category":"page"},{"location":"example_vec/","page":"Walkthrough","title":"Walkthrough","text":"chn2 = chn[:,vcat(pop_info.effect_pos[:indiv_random][:B]...),:]\nchn3 = extract_group(chn2, :indiv_random, indiv_ids)\nnames(chn3)","category":"page"},{"location":"extract_groups/","page":"Extracting effects","title":"Extracting effects","text":"CurrentModule = CrossInverts","category":"page"},{"location":"extract_groups/#Extracting-effects-from-sampled-object","page":"Extracting effects","title":"Extracting effects from sampled object","text":"","category":"section"},{"location":"extract_groups/","page":"Extracting effects","title":"Extracting effects","text":"When setting up the tools using setup_tools_mixed, the ComponentVector effect_pos is returned, which specifies the positions of effects in each sample.","category":"page"},{"location":"extract_groups/","page":"Extracting effects","title":"Extracting effects","text":"First lets mockup a sampling result and corresponding effect positions.","category":"page"},{"location":"extract_groups/","page":"Extracting effects","title":"Extracting effects","text":"using CrossInverts\nusing MCMCChains\nusing ComponentArrays: ComponentArrays as CA\n\n\nchn = Chains(randn((10,21,2)), [\"fixed[:p][1]\", \"fixed[:p][2]\", \"fixed[:p][3]\", \"random[:x][1]\", \"random[:x][2]\", \"random[:τ]\", \"prand_σ[:x][1]\", \"prand_σ[:x][2]\", \"prand_σ[:τ]\", \"indiv[:i, 1]\", \"indiv[:i, 2]\", \"indiv[:i, 3]\", \"indiv_random[:x, 1][1]\", \"indiv_random[:x, 1][2]\", \"indiv_random[:τ, 1]\", \"indiv_random[:x, 2][1]\", \"indiv_random[:x, 2][2]\", \"indiv_random[:τ, 2]\", \"indiv_random[:x, 3][1]\", \"indiv_random[:x, 3][2]\", \"indiv_random[:τ, 3]\"])\n\neffect_pos = CA.ComponentVector(fixed = (p = 1:3,), random = (x = 4:5, τ = 6), \n      random_σ = (x = 7:8, τ = 9), indiv = (A = (i = 10), B = (i = 11), \n      C = (i = 12)), indiv_random = (A = (x = 13:14, τ = 15), \n      B = (x = 16:17, τ = 18), C = (x = 19:20, τ = 21)))\nnothing # hide","category":"page"},{"location":"extract_groups/","page":"Extracting effects","title":"Extracting effects","text":"The effect_pos can be conveniently used to index into a sample, e.g. to extract sub-Chains from the sampling results. Lets get the random multipliers for individual :B, the vector parameter :x and scalar τ.","category":"page"},{"location":"extract_groups/","page":"Extracting effects","title":"Extracting effects","text":"effect_pos[:indiv_random][:B]","category":"page"},{"location":"extract_groups/","page":"Extracting effects","title":"Extracting effects","text":"chn2 = chn[:,vcat(effect_pos[:indiv_random][:B]...),:]\nnames(chn2)","category":"page"},{"location":"extract_groups/","page":"Extracting effects","title":"Extracting effects","text":"The names can be simplified by constraining to a single group using extract_group. In addition, this allows replacing the indices of  individuals by more readable identifiers.","category":"page"},{"location":"extract_groups/","page":"Extracting effects","title":"Extracting effects","text":"indiv_ids = (:A, :B, :C)\nchn3 = extract_group(chn2, :indiv_random, indiv_ids)\nnames(chn3)","category":"page"},{"location":"extract_groups/","page":"Extracting effects","title":"Extracting effects","text":"Alternatively, one can attach the ComponentArrays-Axis  to the array constructed from the chain and index into it.","category":"page"},{"location":"extract_groups/","page":"Extracting effects","title":"Extracting effects","text":"s1 = CA.ComponentMatrix(Array(chn),\n    CA.FlatAxis(), first(CA.getaxes(effect_pos)))\n# sv.p within fixed\ns1[:, :fixed][:, :p]\n# random effects multiplier for site B for random parameter tau\ns1[:, :indiv_random][:, :B][:, :τ]\nnothing # hide","category":"page"},{"location":"extract_groups/#API","page":"Extracting effects","title":"API","text":"","category":"section"},{"location":"extract_groups/","page":"Extracting effects","title":"Extracting effects","text":"extract_group","category":"page"},{"location":"extract_groups/#CrossInverts.extract_group","page":"Extracting effects","title":"CrossInverts.extract_group","text":"extract_group(chn, group::Symbol) \nextract_group(chn, group::Symbol, indiv_ids)\n\nExtract SubChain of components (:fixed, :random, :prand_σ, :indiv, :indiv_random) and replace parameter names like group[:p1, o1]o2 => group[o1]o2. The variant, where indiv_ids is specified, additionally  replaces first [i] by [:(indiv_ids[i])].\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = CrossInverts","category":"page"},{"location":"#CrossInverts","page":"Home","title":"CrossInverts","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for CrossInverts.","category":"page"},{"location":"#Problem","page":"Home","title":"Problem","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"When calibrating models across different groups, some parameters should be kept constant across sites (fixed parameters), some are allowed to vary  around a common mean across sites (random parameters), and others may be allowed to vary freely across groups (individual parameters).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Specifying priors and and dealing with groups and individuals require some common support. Further, keeping the overview across different scenarios can be tedious.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"inversion_case/","page":"Providing inversion information","title":"Providing inversion information","text":"CurrentModule = CrossInverts","category":"page"},{"location":"inversion_case/#Providing-inversion-information","page":"Providing inversion information","title":"Providing inversion information","text":"","category":"section"},{"location":"inversion_case/","page":"Providing inversion information","title":"Providing inversion information","text":"AbstractCrossInversionCase\nget_priors_dict\nget_priors_random_dict\nget_obs_uncertainty_dist_type\nget_indivdata\nget_problemupdater\ndf_from_paramsModeUpperRows","category":"page"},{"location":"inversion_case/#CrossInverts.AbstractCrossInversionCase","page":"Providing inversion information","title":"CrossInverts.AbstractCrossInversionCase","text":"AbstractCrossInversionCase\n\nInterface for providing all relevant information for a cross-individual mixed effects bayesian inversion.\n\nConcrete types should implement\n\nget_priors_dict(::AbstractCrossInversionCase, indiv_id; scenario) Priors for model parameters in fixed, random, and indiv effects. \nget_priors_random_dict(::AbstractCrossInversionCase; scenario) Priors for meta-parameters for random effects.\nget_obs_uncertainty_dist_type(::AbstractCrossInversionCase; scenario) Type of distribution of observation-uncertainty per stream.\nget_indivdata(::AbstractCrossInversionCase, indiv_id; scenario) The times, observations, and uncertainty parameters per indiv_id and stream.\nget_problemupdater(::AbstractCrossInversionCase; system, scenario) A ProblemUpdater for ensuring consistent parameters after setting optimized  parameters.\n\n\n\n\n\n","category":"type"},{"location":"inversion_case/#CrossInverts.get_priors_dict","page":"Providing inversion information","title":"CrossInverts.get_priors_dict","text":"get_priors_dict(::AbstractCrossInversionCase, indiv_id; scenario)\n\nProvide a dictionary (par -> Distribution) for prior parameters and unknowns.\n\n\n\n\n\n","category":"function"},{"location":"inversion_case/#CrossInverts.get_priors_random_dict","page":"Providing inversion information","title":"CrossInverts.get_priors_random_dict","text":"get_priors_random_dict(::AbstractCrossInversionCase; scenario)\n\nProvide a dictionary (par -> Distribution) for prior parameters and unknowns.\n\n\n\n\n\n","category":"function"},{"location":"inversion_case/#CrossInverts.get_obs_uncertainty_dist_type","page":"Providing inversion information","title":"CrossInverts.get_obs_uncertainty_dist_type","text":"get_obs_uncertainty_dist_type(::AbstractCrossInversionCase; scenario)\n\nProvide the type of distribution of observation uncertainty for given stream, to be used with fit_mean_Σ.\n\n\n\n\n\n","category":"function"},{"location":"inversion_case/#CrossInverts.get_indivdata","page":"Providing inversion information","title":"CrossInverts.get_indivdata","text":"get_indivdata(::AbstractCrossInversionCase, indiv_id; scenario)\n\nProvide Tuple (indiv_id -> (stream_info) for each individ. Where StreamInfo is a Tuple `(streamsymbol -> (;t, obs, obstrue)). Such that solution can be indexed by sol[streamsymbol](t) to provide observations. Valueobs_true` is optional. They are synthetic data without noise  generated from the system, which are not used in inversion, but used for comparison.\n\nThe ValueType dispatches to different implementations. There is  am implementation for Val(:CrossInverts_samplesystem1) independent of scenario.\n\n\n\n\n\n","category":"function"},{"location":"inversion_case/#CrossInverts.get_problemupdater","page":"Providing inversion information","title":"CrossInverts.get_problemupdater","text":"get_problemupdater(::AbstractCrossInversionCase; scenario)\n\nReturn a specific ProblemUpdater for given Inversioncase and scennario. It is applied after parameters to optimized have been set. The typical case is optimizing a parameter, but adjusting other non-optimized parameters to be consistent with the optimized one, e.g. always use the same value for another parameter.\n\nThe default is a NullProblemUpdater, which does not modify parameters.    \n\n\n\n\n\n","category":"function"},{"location":"inversion_case/#CrossInverts.df_from_paramsModeUpperRows","page":"Providing inversion information","title":"CrossInverts.df_from_paramsModeUpperRows","text":"df_from_paramsModeUpperRows(paramsModeUpperRows)\n\nConvert Tuple-Rows of (:par, :dType, :med, :upper) to DataFrame. And Fit distribution.\n\n\n\n\n\n","category":"function"},{"location":"inversion_case/#Setup-tools","page":"Providing inversion information","title":"Setup tools","text":"","category":"section"},{"location":"inversion_case/","page":"Providing inversion information","title":"Providing inversion information","text":"get_indiv_parameters_from_priors\nsetup_tools_mixed","category":"page"},{"location":"inversion_case/#CrossInverts.get_indiv_parameters_from_priors","page":"Providing inversion information","title":"CrossInverts.get_indiv_parameters_from_priors","text":"get_indiv_parameters_from_priors(inv_case::AbstractCrossInversionCase,\n        indiv_ids, mixed_keys;\n        scenario, system,\n        rng = StableRNG(234),\n        priors_dict = get_priors_dict(inv_case, missing; scenario),\n        priors_random_dict = get_priors_random_dict(inv_case; scenario),\n        u0_default = ComponentVector(),\n        p_default = ComponentVector(),\n        )\n\nConstruct a DataFrame with parameters across sites with \n\nfixed parameters corresponding to the mean of its prior\nrandom parameters corresponding to mean modified, i.e. multiplied, by sampled  random effects and its meta parameters\nindividual parameters \n\nValue\n\nDataFrame with columns indiv_id, u0 and p, with all states and parameters of the given system as ComponentVector labelled by get_state_labeled and get_par_labeled.\n\n\n\n\n\n","category":"function"},{"location":"inversion_case/#CrossInverts.setup_tools_mixed","page":"Providing inversion information","title":"CrossInverts.setup_tools_mixed","text":"setuptoolsmixed(pindiv::DataFrame;         invcase, scenario = NTuple{0, Symbol}(),          system, mixedkeys,         psets = setuppsetsmixed(invcase; scenario, mixed_keys, system))\n\nGiven inv_case, the keys for different mixed effects, individual state  (u0, p given with p_indiv),  and individual priors, sets up NamedTuple of \n\nmixed: mixed effects NamedTuple(fixed, random, indiv, indiv_random) from individual's states and parameters\ndf: DataFrame p_indiv extended by columns\nparopt: optimized parameters extracted from indiviudals state and parameters\ntools: tools initialized for each site (see setup_tools_indiv)\npsets: NTuple{ODEProblemParSetter} for each mixed component\npriors_pop: ComponentVector of priors on population level (fixed, random, random_σ)\nsample0: ComponentVector of an initial sample This can be used to name (attach_axis) a sample from MCMCChains object \n\n\n\n\n\n","category":"function"},{"location":"inversion_case/#Simulating","page":"Providing inversion information","title":"Simulating","text":"","category":"section"},{"location":"inversion_case/","page":"Providing inversion information","title":"Providing inversion information","text":"gen_sim_sols_probs\ngen_model_cross","category":"page"},{"location":"inversion_case/#CrossInverts.gen_sim_sols_probs","page":"Providing inversion information","title":"CrossInverts.gen_sim_sols_probs","text":"sim_sols_probs(fixed, random, indiv, indiv_random)\n\nUpdate and simulate system (given with tools to gensimsols_probs) by \n\nfor each individual i\nupdate fixed parameters: fixed \nupdate random parameters: random .* indiv_random[:,i]\nupdate indiv_id parameters: indiv[:,i]\nsimulate the problem\nreturn a vector(nindiv) of (;sol, problemopt)\n\nIf non-optimized p and u0 differ between individuals, they must already be set in tools[i_indiv].problem.\n\n\n\n\n\n","category":"function"},{"location":"inversion_case/#CrossInverts.gen_model_cross","page":"Providing inversion information","title":"CrossInverts.gen_model_cross","text":"function gen_model_cross(;\n        inv_case::AbstractCrossInversionCase, tools, priors_pop, sim_sols_probs,\n        scenario, psets, solver)\n\nGenerate a Turing model using objects generated by setup_tools and forward simulation by gen_sim_sols_probs.\n\n\n\n\n\n","category":"function"}]
}
