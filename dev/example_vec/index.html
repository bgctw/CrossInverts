<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Walkthrough · CrossInverts.jl</title><meta name="title" content="Walkthrough · CrossInverts.jl"/><meta property="og:title" content="Walkthrough · CrossInverts.jl"/><meta property="twitter:title" content="Walkthrough · CrossInverts.jl"/><meta name="description" content="Documentation for CrossInverts.jl."/><meta property="og:description" content="Documentation for CrossInverts.jl."/><meta property="twitter:description" content="Documentation for CrossInverts.jl."/><meta property="og:url" content="https://bgctw.github.io/CrossInverts.jl/example_vec/"/><meta property="twitter:url" content="https://bgctw.github.io/CrossInverts.jl/example_vec/"/><link rel="canonical" href="https://bgctw.github.io/CrossInverts.jl/example_vec/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">CrossInverts.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Walkthrough</a><ul class="internal"><li><a class="tocitem" href="#Example-system"><span>Example system</span></a></li><li><a class="tocitem" href="#Extracting-initial-information-and-tools"><span>Extracting initial information and tools</span></a></li><li><a class="tocitem" href="#Forward-simulation"><span>Forward simulation</span></a></li><li><a class="tocitem" href="#Model-Inversion"><span>Model Inversion</span></a></li><li><a class="tocitem" href="#Extracting-individual-effects"><span>Extracting individual effects</span></a></li></ul></li><li><a class="tocitem" href="../extract_groups/">Extracting effects</a></li><li><a class="tocitem" href="../inversion_case/">Providing inversion information</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Walkthrough</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Walkthrough</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/bgctw/CrossInverts.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/bgctw/CrossInverts.jl/blob/main/docs/src/example_vec.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Walkthrough"><a class="docs-heading-anchor" href="#Walkthrough">Walkthrough</a><a id="Walkthrough-1"></a><a class="docs-heading-anchor-permalink" href="#Walkthrough" title="Permalink"></a></h1><p>This example demonstrates how  using an example system with symbolic array state and symbolic array parameters.</p><h2 id="Example-system"><a class="docs-heading-anchor" href="#Example-system">Example system</a><a id="Example-system-1"></a><a class="docs-heading-anchor-permalink" href="#Example-system" title="Permalink"></a></h2><pre><code class="language-julia hljs">using ModelingToolkit, OrdinaryDiffEq
using ModelingToolkit: t_nounits as t, D_nounits as D
using ComponentArrays: ComponentArrays as CA
using MTKHelpers
using CrossInverts
using DistributionFits
using PDMats: PDiagMat
using Turing

function samplesystem_vec(; name, τ = 3.0, i = 0.1, p = [1.1, 1.2, 1.3])
    n_comp = 2
    @parameters t
    D = Differential(t)
    @variables x(..)[1:n_comp] dec2(..)
    ps = @parameters τ=τ i=i i2 p[1:3]=p
    sts = vcat([x(t)[i] for i in 1:n_comp], dec2(t))
    eq = [
        D(x(t)[1]) ~ i - p[1] * x(t)[1] + (p[2] - x(t)[1]^2) / τ,
        D(x(t)[2]) ~ i - dec2(t) + i2,
        dec2(t) ~ p[3] * x(t)[2], # observable
    ]
    sys = ODESystem(eq, t, sts, vcat(ps...); name)
end

@named sv = samplesystem_vec()
@named system = embed_system(sv)</code></pre><p class="math-container">\[ \begin{align}
\frac{\mathrm{d} sv_{+}x\left( t \right)_{1}}{\mathrm{d}t} =&amp; sv_{+}i + \frac{sv_{+}p_{2} - sv_{+}x\left( t \right)_{1}^{2}}{sv_+\tau} - sv_{+}p_{1} sv_{+}x\left( t \right)_{1} \\
\frac{\mathrm{d} sv_{+}x\left( t \right)_{2}}{\mathrm{d}t} =&amp; sv_{+}i + sv_{+}i2 - sv_{+}dec2\left( t \right)
\end{align}
 \]</p><p>First, we define which parameters should be calibrated as fixed, random, or individual parameters. Note, that we can use symbols rather than Symbolics, and can use symbolic arrays rather than requiring the scalarized version.</p><pre><code class="language-julia hljs">mixed_keys = (;
    fixed = (:sv₊p,),
    random = (:sv₊x, :sv₊τ),
    indiv = (:sv₊i,),)

indiv_ids = (:A, :B, :C)</code></pre><h3 id="Priors,-Observations,-and-Observation-uncertainty"><a class="docs-heading-anchor" href="#Priors,-Observations,-and-Observation-uncertainty">Priors, Observations, and Observation uncertainty</a><a id="Priors,-Observations,-and-Observation-uncertainty-1"></a><a class="docs-heading-anchor-permalink" href="#Priors,-Observations,-and-Observation-uncertainty" title="Permalink"></a></h3><p>We need to provide additional information to the inversion, such as observations, observation uncertainties, and prior distribution. This is achieved by overriding specific functions with the first argument being a specific subtype of <a href="../inversion_case/#CrossInverts.AbstractCrossInversionCase">AbstractCrossInversionCase</a> corresponding to the inversion problem.</p><p>Here, we define singleton type <code>DocuVecCase</code> and provide priors with function  <a href="../inversion_case/#CrossInverts.get_priors_dict"><code>get_priors_dict</code></a>. For simplicity we return the same priors independent  of the individual or the scenario. Take care to add methods to the function in module <code>CrossInverts</code> rather define the function in module <code>Main</code>. For the SymbolicArray parameters, we need to provide a Multivariate distribution. Here, we provide a product distribution of uncorrelated LogNormal distributions, which are specified by its mode and upper quantile using <a href="../inversion_case/#CrossInverts.df_from_paramsModeUpperRows"><code>df_from_paramsModeUpperRows</code></a>.</p><pre><code class="language-julia hljs">struct DocuVecCase &lt;: AbstractCrossInversionCase end

function CrossInverts.get_priors_dict(::DocuVecCase, indiv_id; scenario = NTuple{0, Symbol}())
    #using DataFrames, Tables, DistributionFits, Chain
    paramsModeUpperRows = [
        # τ = 3.0, i = 0.1, p = [1.1, 1.2, 1.3])
        (:sv₊i, LogNormal, 1.0, 6.0),
        (:sv₊τ, LogNormal, 1.0, 5.0),
        (:sv₊x_1, LogNormal, 1.0, 2.0),
        (:sv₊x_2, LogNormal, 1.0, 2.0),
    ]
    df_scalars = df_from_paramsModeUpperRows(paramsModeUpperRows)
    dd = Dict{Symbol, Distribution}(df_scalars.par .=&gt; df_scalars.dist)
    dist_p0 = fit(LogNormal, @qp_m(1.0), @qp_uu(3.0))
    # dd[:sv₊p] = product_distribution(fill(dist_p0, 3))
    # dd[:sv₊x] = product_distribution(dd[:sv₊x_1], dd[:sv₊x_2])
    dd[:sv₊p] = product_MvLogNormal(fill(dist_p0, 3)...)
    dd[:sv₊x] = product_MvLogNormal(dd[:sv₊x_1], dd[:sv₊x_2])
    dd
end
function product_MvLogNormal(comp...)
    μ = collect(getproperty.(comp, :μ))
    σ = collect(getproperty.(comp, :σ))
    Σ = PDiagMat(exp.(σ))
    MvLogNormal(μ, Σ)
end

inv_case = DocuVecCase()
scenario = NTuple{0, Symbol}()

get_priors_dict(inv_case, :A; scenario)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{Symbol, Distributions.Distribution} with 6 entries:
  :sv₊x   =&gt; Distributions.MvLogNormal{Float64, PDMats.PDiagMat{Float64, Vector…
  :sv₊i   =&gt; Distributions.LogNormal{Float64}(μ=0.0, σ=0.91418)
  :sv₊x_2 =&gt; Distributions.LogNormal{Float64}(μ=0.0, σ=0.353653)
  :sv₊x_1 =&gt; Distributions.LogNormal{Float64}(μ=0.0, σ=0.353653)
  :sv₊p   =&gt; Distributions.MvLogNormal{Float64, PDMats.PDiagMat{Float64, Vector…
  :sv₊τ   =&gt; Distributions.LogNormal{Float64}(μ=0.0, σ=0.821157)</code></pre><p>Similarly, we provide prior distributions for uncertainty of the random effects by function <a href="../inversion_case/#CrossInverts.get_priors_random_dict"><code>get_priors_random_dict</code></a>.</p><pre><code class="language-julia hljs">function CrossInverts.get_priors_random_dict(::DocuVecCase; scenario = NTuple{0, Symbol}())
    # prior in σ rather than σstar
    d_exp = Exponential(log(1.05))
    dd = Dict{Symbol, Distribution}([:sv₊τ, :sv₊i] .=&gt; d_exp)
    dd[:sv₊x] = Distributions.Product(fill(d_exp, 2))
    dd
end

get_priors_random_dict(inv_case; scenario)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{Symbol, Distributions.Distribution} with 3 entries:
  :sv₊x =&gt; Distributions.Product{Distributions.Continuous, Distributions.Expone…
  :sv₊i =&gt; Distributions.Exponential{Float64}(θ=0.0487902)
  :sv₊τ =&gt; Distributions.Exponential{Float64}(θ=0.0487902)</code></pre><p>Further, the type of distribution of observation uncertainties of  the observations of different data streams by function  <a href="../inversion_case/#CrossInverts.get_obs_uncertainty_dist_type"><code>get_obs_uncertainty_dist_type</code></a>.</p><pre><code class="language-julia hljs">function CrossInverts.get_obs_uncertainty_dist_type(::DocuVecCase, stream;
        scenario = NTuple{0, Symbol}())
    dtypes = Dict{Symbol, Type}(:sv₊dec2 =&gt; LogNormal,
        :sv₊x =&gt; MvLogNormal)
    dtypes[stream]
end

get_obs_uncertainty_dist_type(inv_case, :sv₊dec2; scenario)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Distributions.LogNormal</code></pre><p>Finally, for each</p><ul><li>each individual, </li><li>for each stream, </li></ul><p>we provide a vectors of</p><ul><li>t: time</li><li>obs: observations (vectors for multivariate variables)</li><li>obs_unc: observation uncertainty parameters (can be matrices for multivariate variables)</li><li>obs_true (optionally): values of the true model to be rediscovered in synthetic experiments</li></ul><p>This is done by implementing function <a href="../inversion_case/#CrossInverts.get_indivdata"><code>get_indivdata</code></a>. Usually, this would be read information from a file or database. Here, we provide  the numbers as text.</p><pre><code class="language-julia hljs">function CrossInverts.get_indivdata(::DocuVecCase, indiv_id; scenario = NTuple{0, Symbol}())
    data = (A = (sv₊x = (t = [0.2, 0.4, 1.0, 2.0],
                obs = [
                    [2.3696993004601956, 2.673733320916141],
                    [1.8642844249865063, 2.0994355527637607],
                    [1.9744553950945931, 2.049494086682751],
                    [1.806115091024414, 1.4088107777562726],
                ],
                obs_unc = [
                    [0.09531017980432493 0.0; 0.0 0.09531017980432493],
                    [0.09531017980432493 0.0; 0.0 0.09531017980432493],
                    [0.09531017980432493 0.0; 0.0 0.09531017980432493],
                    [0.09531017980432493 0.0; 0.0 0.09531017980432493],
                ],
                obs_true = [
                    [1.4528506430586314, 1.502300054146255],
                    [1.2174085538439976, 1.1706665606844529],
                    [1.0483430119731987, 0.7600115428483291],
                    [1.0309694961068738, 0.6441417808271487],
                ]),
            sv₊dec2 = (t = [0.2, 0.4, 1.0, 2.0],
                obs = [
                    3.7951565919532038,
                    2.932295276687423,
                    2.0064853619502925,
                    1.6522510350996853,
                ],
                obs_unc = [1.1, 1.1, 1.1, 1.1],
                obs_true = [
                    3.606705597390664,
                    2.810523520548073,
                    1.8246274291924653,
                    1.546448567322152,
                ])),
        B = (sv₊x = (t = [0.2, 0.4, 1.0, 2.0],
                obs = [
                    [2.0681893973690264, 2.76555266499398],
                    [3.002213659926257, 2.738988031384357],
                    [2.2024778579768736, 1.8863521088263966],
                    [1.8970493973645883, 1.4592874111525584],
                ],
                obs_unc = [
                    [0.09531017980432493 0.0; 0.0 0.09531017980432493],
                    [0.09531017980432493 0.0; 0.0 0.09531017980432493],
                    [0.09531017980432493 0.0; 0.0 0.09531017980432493],
                    [0.09531017980432493 0.0; 0.0 0.09531017980432493],
                ],
                obs_true = [
                    [1.4319499386364825, 1.4846599446224278],
                    [1.2097697867481565, 1.1597529395039063],
                    [1.0512489486634184, 0.7574273823278419],
                    [1.035264629162679, 0.6439076211840167],
                ]),
            sv₊dec2 = (t = [0.2, 0.4, 1.0, 2.0],
                obs = [
                    5.286801850397016,
                    2.9649984441621826,
                    2.1180756620394585,
                    2.6749483017364,
                ],
                obs_unc = [1.1, 1.1, 1.1, 1.1],
                obs_true = [
                    3.5643554146940866,
                    2.784322217758367,
                    1.8184234047779861,
                    1.5458863994028762,
                ])),
        C = (sv₊x = (t = [0.2, 0.4, 1.0, 2.0],
                obs = [
                    [2.2350643301157382, 2.3130035358019856],
                    [2.0736166580761624, 1.9436035468232888],
                    [2.0472448291872816, 1.529804596360485],
                    [1.8267544248914431, 1.2760177129115113],
                ],
                obs_unc = [
                    [0.09531017980432493 0.0; 0.0 0.09531017980432493],
                    [0.09531017980432493 0.0; 0.0 0.09531017980432493],
                    [0.09531017980432493 0.0; 0.0 0.09531017980432493],
                    [0.09531017980432493 0.0; 0.0 0.09531017980432493],
                ],
                obs_true = [
                    [1.4810168420659708, 1.502512426277095],
                    [1.226148237932659, 1.1707979724544357],
                    [1.0387515337959667, 0.7600427779041109],
                    [1.0183823891718273, 0.6441445598911335],
                ]),
            sv₊dec2 = (t = [0.2, 0.4, 1.0, 2.0],
                obs = [
                    4.026668907719985,
                    3.1937462073315097,
                    6.2700505882164785,
                    3.4322758342125548,
                ],
                obs_unc = [1.1, 1.1, 1.1, 1.1],
                obs_true = [
                    3.607215458087877,
                    2.8108390124932754,
                    1.8247024179739757,
                    1.5464552392686794,
                ])))
    data[indiv_id]
end

get_indivdata(inv_case, :A; scenario)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(sv₊x = (t = [0.2, 0.4, 1.0, 2.0], obs = [[2.3696993004601956, 2.673733320916141], [1.8642844249865063, 2.0994355527637607], [1.9744553950945931, 2.049494086682751], [1.806115091024414, 1.4088107777562726]], obs_unc = [[0.09531017980432493 0.0; 0.0 0.09531017980432493], [0.09531017980432493 0.0; 0.0 0.09531017980432493], [0.09531017980432493 0.0; 0.0 0.09531017980432493], [0.09531017980432493 0.0; 0.0 0.09531017980432493]], obs_true = [[1.4528506430586314, 1.502300054146255], [1.2174085538439976, 1.1706665606844529], [1.0483430119731987, 0.7600115428483291], [1.0309694961068738, 0.6441417808271487]]), sv₊dec2 = (t = [0.2, 0.4, 1.0, 2.0], obs = [3.7951565919532038, 2.932295276687423, 2.0064853619502925, 1.6522510350996853], obs_unc = [1.1, 1.1, 1.1, 1.1], obs_true = [3.606705597390664, 2.810523520548073, 1.8246274291924653, 1.546448567322152]))</code></pre><p>Often, when one parameter is adjusted, this has consequences for other non-optimized parameters. Function <a href="../inversion_case/#CrossInverts.get_problemupdater"><code>get_problemupdater</code></a> allows to provide a <code>ParameterUpdater</code>  to take care. In this example, when optimizing parameter i, then parameter i2 is set to the same value.</p><pre><code class="language-julia hljs">function CrossInverts.get_problemupdater(::DocuVecCase; system, scenario = NTuple{0, Symbol}())
    mapping = (:sv₊i =&gt; :sv₊i2,)
    pset = ODEProblemParSetter(system, Symbol[]) # parsetter to get state symbols
    get_ode_problemupdater(KeysProblemParGetter(mapping, keys(axis_state(pset))), system)
end

get_problemupdater(inv_case; system, scenario)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">MTKHelpers.ProblemUpdater(MTKHelpers.KeysProblemParGetter{1}((:sv₊i,), (:sv₊i2,), Bool[0]), MTKHelpers.ODEProblemParSetter(Axis(state = 1:0, par = ViewAxis(1:1, Axis(sv₊i2 = 1,))), Axis(sv₊x = 1:2,), Axis(var&quot;(sv₊x(t))[1]&quot; = 1, var&quot;(sv₊x(t))[2]&quot; = 2), Axis(sv₊τ = 1, sv₊i = 2, sv₊i2 = 3, sv₊p = 4:6), Axis(state = 1:0, par = ViewAxis(1:1, Axis(sv₊i2 = 1,))), Axis(sv₊i2 = 1,), SymbolicUtils.BasicSymbolic{Real}[], SymbolicUtils.BasicSymbolic{Real}[sv₊i2], ModelingToolkit.ParameterIndex{SciMLStructures.Tunable, Int64}[ModelingToolkit.ParameterIndex{SciMLStructures.Tunable, Int64}(SciMLStructures.Tunable(), 1, false), ModelingToolkit.ParameterIndex{SciMLStructures.Tunable, Int64}(SciMLStructures.Tunable(), 4, false), ModelingToolkit.ParameterIndex{SciMLStructures.Tunable, Int64}(SciMLStructures.Tunable(), 5, false), ModelingToolkit.ParameterIndex{SciMLStructures.Tunable, Int64}(SciMLStructures.Tunable(), 6, false), ModelingToolkit.ParameterIndex{SciMLStructures.Tunable, Int64}(SciMLStructures.Tunable(), 2, false), ModelingToolkit.ParameterIndex{SciMLStructures.Tunable, Int64}(SciMLStructures.Tunable(), 3, false)], Any[], ModelingToolkit.ParameterIndex{SciMLStructures.Tunable, Int64}[ModelingToolkit.ParameterIndex{SciMLStructures.Tunable, Int64}(SciMLStructures.Tunable(), 5, false)]))</code></pre><h2 id="Extracting-initial-information-and-tools"><a class="docs-heading-anchor" href="#Extracting-initial-information-and-tools">Extracting initial information and tools</a><a id="Extracting-initial-information-and-tools-1"></a><a class="docs-heading-anchor-permalink" href="#Extracting-initial-information-and-tools" title="Permalink"></a></h2><p>A first estimate of the optimized initial state and parameters can then be obtained from priors using function <a href="../inversion_case/#CrossInverts.get_indiv_parameters_from_priors"><code>get_indiv_parameters_from_priors</code></a>. Because parameter <code>i2</code> is not optimized, we specify a value rather than a prior. Next a set of tools is created using function <a href="../inversion_case/#CrossInverts.setup_tools_mixed"><code>setup_tools_mixed</code></a></p><pre><code class="language-julia hljs">p_indiv = get_indiv_parameters_from_priors(inv_case;
    scenario, indiv_ids, mixed_keys, system,
    p_default=CA.ComponentVector(sv₊i2 = 0.1))
(;mixed, indiv_info, pop_info) = setup_tools_mixed(p_indiv;
    inv_case, scenario, system, mixed_keys)
#(psets, priors_pop, sample0, effect_pos) = pop_info
keys(pop_info.sample0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(:fixed, :random, :random_σ, :indiv, :indiv_random)</code></pre><p>A single sample is a ComponentVector with components</p><ul><li>fixed: fixed effects</li><li>random: mean random effects</li><li>random_σ: uncertainty parameter of the random effects</li><li>indiv: Component vector of each site with individual effects</li><li>indiv_random: </li></ul><p>A reminder of the effects:</p><pre><code class="language-julia hljs">mixed_keys</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(fixed = (:sv₊p,), random = (:sv₊x, :sv₊τ), indiv = (:sv₊i,))</code></pre><p>Accessing single components.</p><pre><code class="language-julia hljs">pop_info.sample0[:random]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ComponentVector{Float64}(sv₊x = [2.0518365083230825, 2.0426736579563203], sv₊τ = 1.4265282430633472)</code></pre><pre><code class="language-julia hljs">pop_info.sample0[:indiv][:A]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ComponentVector{Float64}(sv₊i = 1.518711604434893)</code></pre><h2 id="Forward-simulation"><a class="docs-heading-anchor" href="#Forward-simulation">Forward simulation</a><a id="Forward-simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Forward-simulation" title="Permalink"></a></h2><p>Although not necessary for the inversion, it can be helpful for  analysing to do a single forward simulation for all individuals  for a given estimate of the effects.</p><p>First, a function is created using <a href="../inversion_case/#CrossInverts.gen_sim_sols_probs"><code>gen_sim_sols_probs</code></a>  that requires an estimate of the effects, and returns the solution and the updated problem for each individual. Then this function is called with initial estimates.</p><pre><code class="language-julia hljs">solver = AutoTsit5(Rodas5P())
sim_sols_probs = gen_sim_sols_probs(;
    tools = indiv_info.tools, psets = pop_info.psets,
    problemupdater = pop_info.problemupdater, solver)
(fixed, random, indiv, indiv_random) = mixed
sols_probs = sim_sols_probs(fixed, random, indiv, indiv_random)
(sol, problem_opt) = sols_probs[1]
sol[:sv₊x]</code></pre><p>Below we just check that the <code>ProblemUpdater</code> really updated the non-optimized parameter <code>i2</code> to the value of the optimized parameter <code>i</code>.</p><pre><code class="language-julia hljs">pset = pop_info.psets.fixed
get_par_labeled(pset, problem_opt)[:sv₊i2] == get_par_labeled(pset, problem_opt)[:sv₊i]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><h2 id="Model-Inversion"><a class="docs-heading-anchor" href="#Model-Inversion">Model Inversion</a><a id="Model-Inversion-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Inversion" title="Permalink"></a></h2><p>First, a Turing-model is created using <a href="../inversion_case/#CrossInverts.gen_model_cross"><code>gen_model_cross</code></a>. Next, a few samples are drawn from this model using the NUTS sampler.</p><pre><code class="language-julia hljs">model_cross = gen_model_cross(;
    inv_case, tools = indiv_info.tools,
    priors_pop = pop_info.priors_pop, psets = pop_info.psets,
    sim_sols_probs, scenario, solver);

n_burnin = 0
n_sample = 10
chn = Turing.sample(model_cross, Turing.NUTS(n_burnin, 0.65, init_ϵ = 0.2), n_sample,
    init_params = collect(pop_info.sample0))

names(chn, :parameters)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">21-element Vector{Symbol}:
 Symbol(&quot;fixed[:sv₊p][1]&quot;)
 Symbol(&quot;fixed[:sv₊p][2]&quot;)
 Symbol(&quot;fixed[:sv₊p][3]&quot;)
 Symbol(&quot;random[:sv₊x][1]&quot;)
 Symbol(&quot;random[:sv₊x][2]&quot;)
 Symbol(&quot;random[:sv₊τ]&quot;)
 Symbol(&quot;prand_σ[:sv₊x][1]&quot;)
 Symbol(&quot;prand_σ[:sv₊x][2]&quot;)
 Symbol(&quot;prand_σ[:sv₊τ]&quot;)
 Symbol(&quot;indiv[:sv₊i, 1]&quot;)
 ⋮
 Symbol(&quot;indiv_random[:sv₊x, 1][1]&quot;)
 Symbol(&quot;indiv_random[:sv₊x, 1][2]&quot;)
 Symbol(&quot;indiv_random[:sv₊τ, 1]&quot;)
 Symbol(&quot;indiv_random[:sv₊x, 2][1]&quot;)
 Symbol(&quot;indiv_random[:sv₊x, 2][2]&quot;)
 Symbol(&quot;indiv_random[:sv₊τ, 2]&quot;)
 Symbol(&quot;indiv_random[:sv₊x, 3][1]&quot;)
 Symbol(&quot;indiv_random[:sv₊x, 3][2]&quot;)
 Symbol(&quot;indiv_random[:sv₊τ, 3]&quot;)</code></pre><p>For each scalarized value of the effects there is a series of samples.</p><ul><li>a single estimate for each fixed effect. For multivariate variables</li></ul><p>the index is appended last, e.g. <code>Symbol(&quot;fixed[:sv₊p][1]&quot;)</code>.</p><ul><li>a single mean random effect, e.g. <code>Symbol(&quot;random[:sv₊τ]&quot;)</code>.</li><li>an uncertainty parameter of the random effect, e.g. <code>Symbol(&quot;prand_σ[:sv₊τ]&quot;)</code>.</li><li>a individual effect for each individual, e.g. <code>Symbol(&quot;indiv[:sv₊i, 3]&quot;)</code>  for the third individual.</li><li>the individual multiplier for the random effect for each individual, e.g. <code>Symbol(&quot;indiv_random[:sv₊τ, 3]&quot;)</code>.</li></ul><h2 id="Extracting-individual-effects"><a class="docs-heading-anchor" href="#Extracting-individual-effects">Extracting individual effects</a><a id="Extracting-individual-effects-1"></a><a class="docs-heading-anchor-permalink" href="#Extracting-individual-effects" title="Permalink"></a></h2><p>Each row of a multivariate chain can be extracted as a ComponentVector as described in [Extracting effects from sampled object].</p><pre><code class="language-julia hljs">chn2 = chn[:,vcat(pop_info.effect_pos[:indiv_random][:B]...),:]
chn3 = extract_group(chn2, :indiv_random, indiv_ids)
names(chn3)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Symbol}:
 Symbol(&quot;:sv₊x[:B][1]&quot;)
 Symbol(&quot;:sv₊x[:B][2]&quot;)
 Symbol(&quot;:sv₊τ[:B]&quot;)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../extract_groups/">Extracting effects »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Wednesday 7 August 2024 09:30">Wednesday 7 August 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
